<?php
/**
 * This file is part of Lexer package.
 *
 * For the full copyright and license information, please view the
 * LICENSE file that was distributed with this source code.
 */
declare(strict_types=1);

namespace Railt\Compiler\Grammar\Lexer;

use Railt\Compiler\Lexer\Runtime as GrammarRuntime;

/**
 * This class has been auto-generated by the Railt\Compiler\Generator
 */
final class Grammar extends GrammarRuntime
{
    /**#@+
     * List of Grammar::class tokens defined as public constants
     */
    public const T_WHITESPACE      = 'T_WHITESPACE';
    public const T_COMMENT         = 'T_COMMENT';
    public const T_BLOCK_COMMENT   = 'T_BLOCK_COMMENT';
    public const T_PRAGMA          = 'T_PRAGMA';
    public const T_TOKEN           = 'T_TOKEN';
    public const T_SKIP            = 'T_SKIP';
    public const T_INCLUDE         = 'T_INCLUDE';
    public const T_NODE_DEFINITION = 'T_NODE_DEFINITION';
    public const T_OR              = 'T_OR';
    public const T_ZERO_OR_ONE     = 'T_ZERO_OR_ONE';
    public const T_ONE_OR_MORE     = 'T_ONE_OR_MORE';
    public const T_ZERO_OR_MORE    = 'T_ZERO_OR_MORE';
    public const T_N_TO_M          = 'T_N_TO_M';
    public const T_ZERO_TO_M       = 'T_ZERO_TO_M';
    public const T_N_OR_MORE       = 'T_N_OR_MORE';
    public const T_EXACTLY_N       = 'T_EXACTLY_N';
    public const T_SKIPPED         = 'T_SKIPPED';
    public const T_KEPT            = 'T_KEPT';
    public const T_NAMED           = 'T_NAMED';
    public const T_NODE            = 'T_NODE';
    public const T_GROUP_OPEN      = 'T_GROUP_OPEN';
    public const T_GROUP_CLOSE     = 'T_GROUP_CLOSE';
    public const T_EOF             = 'T_EOF';
    /**#@-*/

    /**
     * @var string The PCRE compiled pattern
     */
    protected $pattern = '/\G(?P<T_WHITESPACE>\\s+)|(?P<T_COMMENT>\\/\\/[^\\n]*)|(?P<T_BLOCK_COMMENT>\\/\\*.*?\\*\\/)|(?P<T_PRAGMA>%pragma\\h+([\\w\\.]+)\\h+(.+?)\\s+)|(?P<T_TOKEN>%token\\h+(\\w+)\\h+(.+?)(?:\\h+\\->\\h+(.*?))?\\s+)|(?P<T_SKIP>%skip\\h+(\\w+)\\h+(.+?)\\s+)|(?P<T_INCLUDE>%include\\h+(.+?)\\s+)|(?P<T_NODE_DEFINITION>(#?\\w+)\\s*:)|(?P<T_OR>\\|)|(?P<T_ZERO_OR_ONE>\\?)|(?P<T_ONE_OR_MORE>\\+)|(?P<T_ZERO_OR_MORE>\\*)|(?P<T_N_TO_M>{\\h*(\\d+),\\h*(\\d+)\\h*})|(?P<T_ZERO_TO_M>{\\h*,\\h*(\\d+)\\h*})|(?P<T_N_OR_MORE>{\\h*(\\d+)\\h*,\\h*})|(?P<T_EXACTLY_N>{(\\d+)})|(?P<T_SKIPPED>::(\\w+)::)|(?P<T_KEPT><(\\w+)>)|(?P<T_NAMED>(\\w+)\\(\\))|(?P<T_NODE>#(\\w+))|(?P<T_GROUP_OPEN>\\()|(?P<T_GROUP_CLOSE>\\))/mus';

    /**
     * @var array|bool[] List of tokens in format "[ token_name => kept_or_skipped ]"
     */
    protected $tokens = [
        self::T_WHITESPACE      => false,
        self::T_COMMENT         => false,
        self::T_BLOCK_COMMENT   => false,
        self::T_PRAGMA          => true,
        self::T_TOKEN           => true,
        self::T_SKIP            => true,
        self::T_INCLUDE         => true,
        self::T_NODE_DEFINITION => true,
        self::T_OR              => true,
        self::T_ZERO_OR_ONE     => true,
        self::T_ONE_OR_MORE     => true,
        self::T_ZERO_OR_MORE    => true,
        self::T_N_TO_M          => true,
        self::T_ZERO_TO_M       => true,
        self::T_N_OR_MORE       => true,
        self::T_EXACTLY_N       => true,
        self::T_SKIPPED         => true,
        self::T_KEPT            => true,
        self::T_NAMED           => true,
        self::T_NODE            => true,
        self::T_GROUP_OPEN      => true,
        self::T_GROUP_CLOSE     => true,
        self::T_EOF             => true,
            ];

    /**
     * @return string Returns the lexer compilation date and time in RFC3339 format
     */
    public function getBuiltDate(): string
    {
        return '2018-03-20MSK22:46:41.422+03:00';
    }
}
