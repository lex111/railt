<?php
/**
 * This file is part of Lexer package.
 *
 * For the full copyright and license information, please view the
 * LICENSE file that was distributed with this source code.
 */
declare(strict_types=1);

namespace Railt\Compiler\Grammar\Lexer;

use Railt\Compiler\Lexer\NativeStateful as GrammarRuntime;

/**
 * This class has been auto-generated by the Railt\Compiler\Generator
 */
final class Grammar extends GrammarRuntime
{
    /**#@+
     * List of Grammar::class tokens defined as public constants
     */
    public const T_WHITESPACE      = 'T_WHITESPACE';
    public const T_COMMENT         = 'T_COMMENT';
    public const T_BLOCK_COMMENT   = 'T_BLOCK_COMMENT';
    public const T_PRAGMA          = 'T_PRAGMA';
    public const T_TOKEN           = 'T_TOKEN';
    public const T_SKIP            = 'T_SKIP';
    public const T_INCLUDE         = 'T_INCLUDE';
    public const T_NODE_DEFINITION = 'T_NODE_DEFINITION';
    public const T_OR              = 'T_OR';
    public const T_ZERO_OR_ONE     = 'T_ZERO_OR_ONE';
    public const T_ONE_OR_MORE     = 'T_ONE_OR_MORE';
    public const T_ZERO_OR_MORE    = 'T_ZERO_OR_MORE';
    public const T_N_TO_M          = 'T_N_TO_M';
    public const T_ZERO_TO_M       = 'T_ZERO_TO_M';
    public const T_N_OR_MORE       = 'T_N_OR_MORE';
    public const T_EXACTLY_N       = 'T_EXACTLY_N';
    public const T_SKIPPED         = 'T_SKIPPED';
    public const T_KEPT            = 'T_KEPT';
    public const T_NAMED           = 'T_NAMED';
    public const T_NODE            = 'T_NODE';
    public const T_GROUP_OPEN      = 'T_GROUP_OPEN';
    public const T_GROUP_CLOSE     = 'T_GROUP_CLOSE';
    /**#@-*/

    /**
     * Grammar constructor must be redefined to
     * correctly reproduce the basic implementation.
     */
    public function __construct()
    {
        parent::__construct('/\\G(?P<T_WHITESPACE>\\s+)|(?P<T_COMMENT>\\/\\/[^\\n]*)|(?P<T_BLOCK_COMMENT>\\/\\*.*?\\*\\/)|(?P<T_PRAGMA>%pragma\\h+([\\w\\.]+)\\h+(.+?)\\s+)|(?P<T_TOKEN>%token\\h+(\\w+)\\h+(.+?)(?:\\h+\\->\\h+(\\w+))?\\s+)|(?P<T_SKIP>%skip\\h+(\\w+)\\h+(.+?)\\s+)|(?P<T_INCLUDE>%include\\h+(.+?)\\s+)|(?P<T_NODE_DEFINITION>(#?\\w+)\\s*:)|(?P<T_OR>\\|)|(?P<T_ZERO_OR_ONE>\\?)|(?P<T_ONE_OR_MORE>\\+)|(?P<T_ZERO_OR_MORE>\\*)|(?P<T_N_TO_M>{\\h*(\\d+),\\h*(\\d+)\\h*})|(?P<T_ZERO_TO_M>{\\h*,\\h*(\\d+)\\h*})|(?P<T_N_OR_MORE>{\\h*(\\d+)\\h*,\\h*})|(?P<T_EXACTLY_N>{(\\d+)})|(?P<T_SKIPPED>::(\\w+)::)|(?P<T_KEPT><(\\w+)>)|(?P<T_NAMED>(\\w+)\\(\\))|(?P<T_NODE>#(\\w+))|(?P<T_GROUP_OPEN>\\()|(?P<T_GROUP_CLOSE>\\))|.*?/usS', ['T_WHITESPACE', 'T_COMMENT', 'T_BLOCK_COMMENT']);
    }

    /**
     * Returns the lexer compilation date and time in RFC3339 format
     *
     * @return string
     */
    public function getBuiltDate(): string
    {
        return '2018-03-27T20:42:12.523+00:00';
    }
}
